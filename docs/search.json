[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "compbio_webpage2.0_2026",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\nHomework 1: Homework 1\nHomework 3: Homework 3\nHomework 4: Homework 4"
  },
  {
    "objectID": "homework3.html",
    "href": "homework3.html",
    "title": "Homework 3",
    "section": "",
    "text": "# Setting up variables:\nx &lt;- 1.1\na &lt;- 2.2\nb &lt;- 3.3\n\n# Assigning z to each expression\n# 1a:\nz &lt;- x^(a^b)\nprint(z)\n\n[1] 3.61714\n\n# 1b:\nz &lt;- (x^a)^b\nprint(z)\n\n[1] 1.997611\n\n# 1c:\nz &lt;- ((3*x^3)+(2*x^2)+(1))\n\nprint(z)\n\n[1] 7.413\n\n\n\n\n\n\n# 2a:\n# concatenating two seqs\nvec1 &lt;- c(seq(from=1, to=8), seq(from=7, to=1))\nprint(vec1)\n\n [1] 1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\n\n# 2b:\n# repeating 1 through 5 and using a vector inside of times to repeat numbers\nvec2 &lt;- rep(x=c(1:5), times=c(1:5))\nprint(vec2)\n\n [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5\n\n# 2c:\n# repeating 5 through 1 and using a vector inside of times to repeat numbers\nvec3 &lt;- rep(x=c(5:1), times=c(1:5))\nprint(vec3)\n\n [1] 5 4 4 3 3 3 2 2 2 2 1 1 1 1 1\n\n\n\n\n\n\n# using runif to generate two random cart coordinates\ncart &lt;- c(runif(1), runif(1))\nprint(cart)\n\n[1] 0.5433304 0.3316042\n\n# creating r and theta for polar coordinates\nr &lt;- sqrt((cart[1]^2) + (cart[2]^2))\ntheta &lt;- atan((cart[1]) / (cart[2]))\n\n# assigning polar coordinates\npol &lt;- c(r, theta)\nprint(pol)\n\n[1] 0.6365291 1.0228248\n\n\n\n\n\n\n# assigned queue\nqueue &lt;- c(\"sheep\", \"fox\", \"owl\", \"ant\")\nqueue &lt;- c(queue, \"serpent\")\nqueue &lt;- queue[-1]\nqueue &lt;- c(\"donkey\", queue)\nqueue &lt;- queue[-5]\nqueue &lt;- queue[-3]\nqueue &lt;- c(queue[1:2], \"aphid\", queue[3])\n\n# using which to figure out where aphid is\nwhich(queue==\"aphid\")\n\n[1] 3\n\n\n\n\n\n\n# assigning ints as a vector of 1 through 100\nints &lt;- c(1:100)\n\n# using a combo of indexing and which. Basically asking for the index to find number where the remainder of division is not 0 for each number.\nnot_div &lt;- ints[which(ints %% 2 != 0 & ints %% 3 != 0 & ints %% 7 != 0)] \n\nprint(not_div)\n\n [1]  1  5 11 13 17 19 23 25 29 31 37 41 43 47 53 55 59 61 65 67 71 73 79 83 85\n[26] 89 95 97"
  },
  {
    "objectID": "homework3.html#homework-3",
    "href": "homework3.html#homework-3",
    "title": "Homework 3",
    "section": "",
    "text": "# Setting up variables:\nx &lt;- 1.1\na &lt;- 2.2\nb &lt;- 3.3\n\n# Assigning z to each expression\n# 1a:\nz &lt;- x^(a^b)\nprint(z)\n\n[1] 3.61714\n\n# 1b:\nz &lt;- (x^a)^b\nprint(z)\n\n[1] 1.997611\n\n# 1c:\nz &lt;- ((3*x^3)+(2*x^2)+(1))\n\nprint(z)\n\n[1] 7.413\n\n\n\n\n\n\n# 2a:\n# concatenating two seqs\nvec1 &lt;- c(seq(from=1, to=8), seq(from=7, to=1))\nprint(vec1)\n\n [1] 1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\n\n# 2b:\n# repeating 1 through 5 and using a vector inside of times to repeat numbers\nvec2 &lt;- rep(x=c(1:5), times=c(1:5))\nprint(vec2)\n\n [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5\n\n# 2c:\n# repeating 5 through 1 and using a vector inside of times to repeat numbers\nvec3 &lt;- rep(x=c(5:1), times=c(1:5))\nprint(vec3)\n\n [1] 5 4 4 3 3 3 2 2 2 2 1 1 1 1 1\n\n\n\n\n\n\n# using runif to generate two random cart coordinates\ncart &lt;- c(runif(1), runif(1))\nprint(cart)\n\n[1] 0.5433304 0.3316042\n\n# creating r and theta for polar coordinates\nr &lt;- sqrt((cart[1]^2) + (cart[2]^2))\ntheta &lt;- atan((cart[1]) / (cart[2]))\n\n# assigning polar coordinates\npol &lt;- c(r, theta)\nprint(pol)\n\n[1] 0.6365291 1.0228248\n\n\n\n\n\n\n# assigned queue\nqueue &lt;- c(\"sheep\", \"fox\", \"owl\", \"ant\")\nqueue &lt;- c(queue, \"serpent\")\nqueue &lt;- queue[-1]\nqueue &lt;- c(\"donkey\", queue)\nqueue &lt;- queue[-5]\nqueue &lt;- queue[-3]\nqueue &lt;- c(queue[1:2], \"aphid\", queue[3])\n\n# using which to figure out where aphid is\nwhich(queue==\"aphid\")\n\n[1] 3\n\n\n\n\n\n\n# assigning ints as a vector of 1 through 100\nints &lt;- c(1:100)\n\n# using a combo of indexing and which. Basically asking for the index to find number where the remainder of division is not 0 for each number.\nnot_div &lt;- ints[which(ints %% 2 != 0 & ints %% 3 != 0 & ints %% 7 != 0)] \n\nprint(not_div)\n\n [1]  1  5 11 13 17 19 23 25 29 31 37 41 43 47 53 55 59 61 65 67 71 73 79 83 85\n[26] 89 95 97"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site: this is a test to make sure things work"
  },
  {
    "objectID": "homework1.html",
    "href": "homework1.html",
    "title": "homework1",
    "section": "",
    "text": "This is Homework 1. It contains some R code.\n\nx=c(1,2,3,4)\n\ny=c(\"a\",\"b\",\"c\",\"d\")\n\nprint(x)\n\n[1] 1 2 3 4\n\nprint(y)\n\n[1] \"a\" \"b\" \"c\" \"d\""
  },
  {
    "objectID": "homework4.html",
    "href": "homework4.html",
    "title": "Homework 4",
    "section": "",
    "text": "Assign to the variable n_dims a single random integer between 3 and 10.\n\n\n# Assign to the variable n_dims a single random integer between 3 and 10.\nn_dims &lt;- sample(x=3:10, size=1)\nprint(n_dims)\n\n[1] 5\n\n# Create a vector of consecutive integers from 1 to n_dims^2\nn_vec &lt;- 1:n_dims^2\nprint(n_vec)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n\n# Use the sample function to randomly reshuffle these values\nn_shuffle &lt;- sample(x=n_vec, size=length(n_vec))\nprint(n_shuffle)\n\n [1]  4  5 15 18  2  6  7 22 11  1 14 24 23 16 19 10 25  3 12  8 20 13 21  9 17\n\n# create a square matrix with these elements\nn_mat &lt;- matrix(data=n_shuffle, nrow=sqrt(length(n_shuffle)))\n\n# print out the matrix\nprint(n_mat)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    4    6   14   10   20\n[2,]    5    7   24   25   13\n[3,]   15   22   23    3   21\n[4,]   18   11   16   12    9\n[5,]    2    1   19    8   17\n\n# find a function in r to transpose the matrix\nn_transpose &lt;- t(n_mat)\n\n# print it out again and note how it has changed.\nprint(n_transpose)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    4    5   15   18    2\n[2,]    6    7   22   11    1\n[3,]   14   24   23   16   19\n[4,]   10   25    3   12    8\n[5,]   20   13   21    9   17\n\n# calculate the sum and the mean of the elements in the first row and then the last row\nsum(n_transpose[1,])\n\n[1] 44\n\nmean(n_transpose[1,])\n\n[1] 8.8\n\nsum(n_transpose[sqrt(length(n_transpose)),])\n\n[1] 80\n\nmean(n_transpose[sqrt(length(n_transpose)),])\n\n[1] 16\n\n# read about the eigen() function and use it on your matrix\nn_eigen &lt;- eigen(n_transpose)\n\n# look carefully at the elements of $values and $vectors in the output. What kind of numbers are these?\n# dig in with the typeof() function to figure out their type.\ntypeof(n_eigen$values)\n\n[1] \"complex\"\n\ntypeof(n_eigen$vectors)\n\n[1] \"complex\"\n\n# These are all doubles\n# on my first run they were all doubles, but then rerunning it turned complex\n\n\nCreate a list with the following named elements:\n\n\n#  4 x 4 matrix filled with random uniform values\nmy_matrix &lt;- matrix(runif(16), nrow=4)\n\n# 100-element vector of TRUE or FALSE values. Do this efficiently by setting up a vector of random values and then applying an inequality to it\nmy_logical &lt;- sample(1:100, size=100) &gt; 50\n\n# 26-element vector of all the lower-case letters in random order\nmy_letters &lt;- sample(letters, size=26)\n\n### Then, complete the following steps:\n# create a new list, which has the element[2,2] from the matrix, the second element of the logical vector, and the second element of the letters vector.\nnew_list &lt;- list(m=my_matrix[2,2], lo=my_logical[2], le=my_letters[2])\ntypeof(new_list$m)\n\n[1] \"double\"\n\ntypeof(new_list$lo)\n\n[1] \"logical\"\n\ntypeof(new_list$le)\n\n[1] \"character\"\n\n# combine the underlying elements from the new list into a single atomic vector with the c() function\nnew_vec &lt;- c(new_list$m, new_list$lo, new_list$le)\ntypeof(new_vec)\n\n[1] \"character\"\n\n# this is type character.\n\n\nCreate a data frame with the two variables (= columns) and 26 cases (= rows) below:\n\n\ndf &lt;- data.frame(\n    # call the first variable my_unis and fill it with 26 random uniform values from 0 to 10\n    my_unis = runif(26, min=0, max=10),\n    # call the second variable my_letters and fill it with 26 capital letters in random order\n    my_letters = sample(LETTERS, 26)\n    )\n\n# for the first variable, use a single line of code in R to select 4 random rows and replace the numerical values in those rows with NA\n\n# m[1,1] &lt;- NA\n# m[5,4] &lt;- NA\n\ndf[sample(1:26, size=4), 1] &lt;- NA\n\n# for the first variable, write a single line of R code to identify which rows have the missing values.\nwhich(!complete.cases(df))\n\n[1] 13 21 25 26\n\n# re-order the entire data frame to arrange the second variable in alphabetical order\ndf &lt;- data.frame(df[,1], sort(df[,2]))\n\n# calculate the column mean for the first variable\nmean(df[,1], na.rm = T)\n\n[1] 4.023931"
  },
  {
    "objectID": "homework4.html#homework-4",
    "href": "homework4.html#homework-4",
    "title": "Homework 4",
    "section": "",
    "text": "Assign to the variable n_dims a single random integer between 3 and 10.\n\n\n# Assign to the variable n_dims a single random integer between 3 and 10.\nn_dims &lt;- sample(x=3:10, size=1)\nprint(n_dims)\n\n[1] 5\n\n# Create a vector of consecutive integers from 1 to n_dims^2\nn_vec &lt;- 1:n_dims^2\nprint(n_vec)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n\n# Use the sample function to randomly reshuffle these values\nn_shuffle &lt;- sample(x=n_vec, size=length(n_vec))\nprint(n_shuffle)\n\n [1]  4  5 15 18  2  6  7 22 11  1 14 24 23 16 19 10 25  3 12  8 20 13 21  9 17\n\n# create a square matrix with these elements\nn_mat &lt;- matrix(data=n_shuffle, nrow=sqrt(length(n_shuffle)))\n\n# print out the matrix\nprint(n_mat)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    4    6   14   10   20\n[2,]    5    7   24   25   13\n[3,]   15   22   23    3   21\n[4,]   18   11   16   12    9\n[5,]    2    1   19    8   17\n\n# find a function in r to transpose the matrix\nn_transpose &lt;- t(n_mat)\n\n# print it out again and note how it has changed.\nprint(n_transpose)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    4    5   15   18    2\n[2,]    6    7   22   11    1\n[3,]   14   24   23   16   19\n[4,]   10   25    3   12    8\n[5,]   20   13   21    9   17\n\n# calculate the sum and the mean of the elements in the first row and then the last row\nsum(n_transpose[1,])\n\n[1] 44\n\nmean(n_transpose[1,])\n\n[1] 8.8\n\nsum(n_transpose[sqrt(length(n_transpose)),])\n\n[1] 80\n\nmean(n_transpose[sqrt(length(n_transpose)),])\n\n[1] 16\n\n# read about the eigen() function and use it on your matrix\nn_eigen &lt;- eigen(n_transpose)\n\n# look carefully at the elements of $values and $vectors in the output. What kind of numbers are these?\n# dig in with the typeof() function to figure out their type.\ntypeof(n_eigen$values)\n\n[1] \"complex\"\n\ntypeof(n_eigen$vectors)\n\n[1] \"complex\"\n\n# These are all doubles\n# on my first run they were all doubles, but then rerunning it turned complex\n\n\nCreate a list with the following named elements:\n\n\n#  4 x 4 matrix filled with random uniform values\nmy_matrix &lt;- matrix(runif(16), nrow=4)\n\n# 100-element vector of TRUE or FALSE values. Do this efficiently by setting up a vector of random values and then applying an inequality to it\nmy_logical &lt;- sample(1:100, size=100) &gt; 50\n\n# 26-element vector of all the lower-case letters in random order\nmy_letters &lt;- sample(letters, size=26)\n\n### Then, complete the following steps:\n# create a new list, which has the element[2,2] from the matrix, the second element of the logical vector, and the second element of the letters vector.\nnew_list &lt;- list(m=my_matrix[2,2], lo=my_logical[2], le=my_letters[2])\ntypeof(new_list$m)\n\n[1] \"double\"\n\ntypeof(new_list$lo)\n\n[1] \"logical\"\n\ntypeof(new_list$le)\n\n[1] \"character\"\n\n# combine the underlying elements from the new list into a single atomic vector with the c() function\nnew_vec &lt;- c(new_list$m, new_list$lo, new_list$le)\ntypeof(new_vec)\n\n[1] \"character\"\n\n# this is type character.\n\n\nCreate a data frame with the two variables (= columns) and 26 cases (= rows) below:\n\n\ndf &lt;- data.frame(\n    # call the first variable my_unis and fill it with 26 random uniform values from 0 to 10\n    my_unis = runif(26, min=0, max=10),\n    # call the second variable my_letters and fill it with 26 capital letters in random order\n    my_letters = sample(LETTERS, 26)\n    )\n\n# for the first variable, use a single line of code in R to select 4 random rows and replace the numerical values in those rows with NA\n\n# m[1,1] &lt;- NA\n# m[5,4] &lt;- NA\n\ndf[sample(1:26, size=4), 1] &lt;- NA\n\n# for the first variable, write a single line of R code to identify which rows have the missing values.\nwhich(!complete.cases(df))\n\n[1] 13 21 25 26\n\n# re-order the entire data frame to arrange the second variable in alphabetical order\ndf &lt;- data.frame(df[,1], sort(df[,2]))\n\n# calculate the column mean for the first variable\nmean(df[,1], na.rm = T)\n\n[1] 4.023931"
  }
]