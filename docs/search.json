[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "compbio_webpage2.0_2026",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\nHomework 1: Homework 1\nHomework 3: Homework 3\nHomework 4: Homework 4\nHomework 5: Homework 5\nHomework 6: Homework 6\nHomework 7: Homework 7"
  },
  {
    "objectID": "homework6.html",
    "href": "homework6.html",
    "title": "Homework 6",
    "section": "",
    "text": "Create a function that takes as its inputs, vectors for β (the transmission rate) and γ (the recovery rate). This function will output a dataframe that includes the max number of infected individuals for each parameter combination.\n\nPremade function for question 1:\n\nlibrary(deSolve)\n\n############################################################\n# FUNCTION: run_sir_model\n# PURPOSE: Solve deterministic SIR model with deSolve\n# INPUTS:\n#   beta, gamma : transmission & recovery rates\n#   N           : total population\n#   S0, I0, R0  : initial conditions\n#   t_start     : start time\n#   t_end       : end time\n#   dt          : timestep\n# OUTPUT:\n#   data.frame with columns: time, S, I, R\n############################################################\n# The function below solves the SIR model for a single parameter set and will be used inside your loops to conduct the parameter sweep.\n\nrun_sir_model &lt;- function(\n  beta    = 0.1,\n  gamma   = 0.1,\n  N       = 1000,\n  S0      = 999,\n  I0      = 1,\n  R0      = 0,\n  t_start = 0,\n  t_end   = 160,\n  dt      = 1\n) {\n\n  init  &lt;- c(S = S0, I = I0, R = R0)\n  times &lt;- seq(t_start, t_end, by = dt)\n\n  sir_equations &lt;- function(time, state, parameters) {\n    with(as.list(c(state, parameters)), {\n      dS &lt;- -beta * S * I / N\n      dI &lt;-  beta * S * I / N - gamma * I\n      dR &lt;-  gamma * I\n      list(c(dS, dI, dR))\n    })\n  }\n\n  out &lt;- ode(\n    y     = init,\n    times = times,\n    func  = sir_equations,\n    parms = c(beta = beta, gamma = gamma, N = N)\n  )\n\n  as.data.frame(out)\n}\n\nStart of my code:\n\n# creating parameter vectors\nbeta_vec &lt;- seq(from = 0, to = 0.5, by = 0.01)\ngamma_vec &lt;- seq(from = 0, to = 0.5, by = 0.01)\n\n# test code\nbeta_params=beta_vec\ngamma_params=gamma_vec\n\n# start of function \"sir_param_sweep\"\n\nsir_param_sweep &lt;- function(\n    beta_params,\n    gamma_params\n){\n    \n    ### Creating storage df:\n    # finding the length of the df\n    df_l &lt;- length(beta_params)*length(gamma_params)\n\n    # creating each column in the df\n    beta_out &lt;- rep(NA, df_l)\n    gamma_out &lt;- rep(NA, df_l)\n    max_infected &lt;- rep(NA, df_l)\n\n    # creating the df\n    storage_df &lt;- data.frame(beta_out, gamma_out, max_infected)\n\n    counter &lt;- 1\n\n    for(i in seq_along(beta_params)){\n        for(j in seq_along(gamma_params)){\n\n            # run sir model\n            temp_df &lt;- run_sir_model(beta = beta_params[i], gamma = gamma_params[j])\n\n            # store variables inside df\n            storage_df$max_infected[counter] &lt;- max(temp_df$I)\n            storage_df$beta_out[counter] &lt;- beta_params[i]\n            storage_df$gamma_out[counter] &lt;- gamma_params[j]\n\n            # increasing the counter\n            counter &lt;- counter + 1\n            }\n        }\n\n  return(storage_df)\n\n}\n\n# run_sir_model()\n\ntest_param_sweep &lt;- sir_param_sweep(beta_params = beta_vec, gamma_params = gamma_vec)\n\nlibrary(ggplot2)\n\nggplot(test_param_sweep, aes(x = beta_out, y = gamma_out, fill = max_infected)) + geom_tile()\n\n\n\n\n\n\n\n\n\nCreate a second function that takes the above outputted dataframe as its input and creates a heatmap of max(number of infected) with Transmission Rate, β and Recovery Rate, γ as your x and y axises.\n\n\nplot_param_sweep &lt;- function(\n    param_df\n){\n    ggplot(param_df, aes(x = beta_out, y = gamma_out, fill = max_infected)) + geom_tile() + xlab(\"Transmission Rate, Beta\") + ylab(\"Recovery Rate, Gamma\") + labs(fill = \"Max Infected\")\n}\n\nplot_param_sweep(test_param_sweep)"
  },
  {
    "objectID": "homework6.html#homework-6",
    "href": "homework6.html#homework-6",
    "title": "Homework 6",
    "section": "",
    "text": "Create a function that takes as its inputs, vectors for β (the transmission rate) and γ (the recovery rate). This function will output a dataframe that includes the max number of infected individuals for each parameter combination.\n\nPremade function for question 1:\n\nlibrary(deSolve)\n\n############################################################\n# FUNCTION: run_sir_model\n# PURPOSE: Solve deterministic SIR model with deSolve\n# INPUTS:\n#   beta, gamma : transmission & recovery rates\n#   N           : total population\n#   S0, I0, R0  : initial conditions\n#   t_start     : start time\n#   t_end       : end time\n#   dt          : timestep\n# OUTPUT:\n#   data.frame with columns: time, S, I, R\n############################################################\n# The function below solves the SIR model for a single parameter set and will be used inside your loops to conduct the parameter sweep.\n\nrun_sir_model &lt;- function(\n  beta    = 0.1,\n  gamma   = 0.1,\n  N       = 1000,\n  S0      = 999,\n  I0      = 1,\n  R0      = 0,\n  t_start = 0,\n  t_end   = 160,\n  dt      = 1\n) {\n\n  init  &lt;- c(S = S0, I = I0, R = R0)\n  times &lt;- seq(t_start, t_end, by = dt)\n\n  sir_equations &lt;- function(time, state, parameters) {\n    with(as.list(c(state, parameters)), {\n      dS &lt;- -beta * S * I / N\n      dI &lt;-  beta * S * I / N - gamma * I\n      dR &lt;-  gamma * I\n      list(c(dS, dI, dR))\n    })\n  }\n\n  out &lt;- ode(\n    y     = init,\n    times = times,\n    func  = sir_equations,\n    parms = c(beta = beta, gamma = gamma, N = N)\n  )\n\n  as.data.frame(out)\n}\n\nStart of my code:\n\n# creating parameter vectors\nbeta_vec &lt;- seq(from = 0, to = 0.5, by = 0.01)\ngamma_vec &lt;- seq(from = 0, to = 0.5, by = 0.01)\n\n# test code\nbeta_params=beta_vec\ngamma_params=gamma_vec\n\n# start of function \"sir_param_sweep\"\n\nsir_param_sweep &lt;- function(\n    beta_params,\n    gamma_params\n){\n    \n    ### Creating storage df:\n    # finding the length of the df\n    df_l &lt;- length(beta_params)*length(gamma_params)\n\n    # creating each column in the df\n    beta_out &lt;- rep(NA, df_l)\n    gamma_out &lt;- rep(NA, df_l)\n    max_infected &lt;- rep(NA, df_l)\n\n    # creating the df\n    storage_df &lt;- data.frame(beta_out, gamma_out, max_infected)\n\n    counter &lt;- 1\n\n    for(i in seq_along(beta_params)){\n        for(j in seq_along(gamma_params)){\n\n            # run sir model\n            temp_df &lt;- run_sir_model(beta = beta_params[i], gamma = gamma_params[j])\n\n            # store variables inside df\n            storage_df$max_infected[counter] &lt;- max(temp_df$I)\n            storage_df$beta_out[counter] &lt;- beta_params[i]\n            storage_df$gamma_out[counter] &lt;- gamma_params[j]\n\n            # increasing the counter\n            counter &lt;- counter + 1\n            }\n        }\n\n  return(storage_df)\n\n}\n\n# run_sir_model()\n\ntest_param_sweep &lt;- sir_param_sweep(beta_params = beta_vec, gamma_params = gamma_vec)\n\nlibrary(ggplot2)\n\nggplot(test_param_sweep, aes(x = beta_out, y = gamma_out, fill = max_infected)) + geom_tile()\n\n\n\n\n\n\n\n\n\nCreate a second function that takes the above outputted dataframe as its input and creates a heatmap of max(number of infected) with Transmission Rate, β and Recovery Rate, γ as your x and y axises.\n\n\nplot_param_sweep &lt;- function(\n    param_df\n){\n    ggplot(param_df, aes(x = beta_out, y = gamma_out, fill = max_infected)) + geom_tile() + xlab(\"Transmission Rate, Beta\") + ylab(\"Recovery Rate, Gamma\") + labs(fill = \"Max Infected\")\n}\n\nplot_param_sweep(test_param_sweep)"
  },
  {
    "objectID": "homework4.html",
    "href": "homework4.html",
    "title": "Homework 4",
    "section": "",
    "text": "Assign to the variable n_dims a single random integer between 3 and 10.\n\n\n# Assign to the variable n_dims a single random integer between 3 and 10.\nn_dims &lt;- sample(x=3:10, size=1)\nprint(n_dims)\n\n[1] 4\n\n# Create a vector of consecutive integers from 1 to n_dims^2\nn_vec &lt;- 1:n_dims^2\nprint(n_vec)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16\n\n# Use the sample function to randomly reshuffle these values\nn_shuffle &lt;- sample(x=n_vec, size=length(n_vec))\nprint(n_shuffle)\n\n [1]  8  5  1  2  6  4  9 14 11 13  7 16 15  3 10 12\n\n# create a square matrix with these elements\nn_mat &lt;- matrix(data=n_shuffle, nrow=sqrt(length(n_shuffle)))\n\n# print out the matrix\nprint(n_mat)\n\n     [,1] [,2] [,3] [,4]\n[1,]    8    6   11   15\n[2,]    5    4   13    3\n[3,]    1    9    7   10\n[4,]    2   14   16   12\n\n# find a function in r to transpose the matrix\nn_transpose &lt;- t(n_mat)\n\n# print it out again and note how it has changed.\nprint(n_transpose)\n\n     [,1] [,2] [,3] [,4]\n[1,]    8    5    1    2\n[2,]    6    4    9   14\n[3,]   11   13    7   16\n[4,]   15    3   10   12\n\n# calculate the sum and the mean of the elements in the first row and then the last row\nsum(n_transpose[1,])\n\n[1] 16\n\nmean(n_transpose[1,])\n\n[1] 4\n\nsum(n_transpose[sqrt(length(n_transpose)),])\n\n[1] 40\n\nmean(n_transpose[sqrt(length(n_transpose)),])\n\n[1] 10\n\n# read about the eigen() function and use it on your matrix\nn_eigen &lt;- eigen(n_transpose)\n\n# look carefully at the elements of $values and $vectors in the output. What kind of numbers are these?\n# dig in with the typeof() function to figure out their type.\ntypeof(n_eigen$values)\n\n[1] \"complex\"\n\ntypeof(n_eigen$vectors)\n\n[1] \"complex\"\n\n# These are all doubles\n# on my first run they were all doubles, but then rerunning it turned complex\n\n\nCreate a list with the following named elements:\n\n\n#  4 x 4 matrix filled with random uniform values\nmy_matrix &lt;- matrix(runif(16), nrow=4)\n\n# 100-element vector of TRUE or FALSE values. Do this efficiently by setting up a vector of random values and then applying an inequality to it\nmy_logical &lt;- sample(1:100, size=100) &gt; 50\n\n# 26-element vector of all the lower-case letters in random order\nmy_letters &lt;- sample(letters, size=26)\n\n### Then, complete the following steps:\n# create a new list, which has the element[2,2] from the matrix, the second element of the logical vector, and the second element of the letters vector.\nnew_list &lt;- list(m=my_matrix[2,2], lo=my_logical[2], le=my_letters[2])\ntypeof(new_list$m)\n\n[1] \"double\"\n\ntypeof(new_list$lo)\n\n[1] \"logical\"\n\ntypeof(new_list$le)\n\n[1] \"character\"\n\n# combine the underlying elements from the new list into a single atomic vector with the c() function\nnew_vec &lt;- c(new_list$m, new_list$lo, new_list$le)\ntypeof(new_vec)\n\n[1] \"character\"\n\n# this is type character.\n\n\nCreate a data frame with the two variables (= columns) and 26 cases (= rows) below:\n\n\ndf &lt;- data.frame(\n    # call the first variable my_unis and fill it with 26 random uniform values from 0 to 10\n    my_unis = runif(26, min=0, max=10),\n    # call the second variable my_letters and fill it with 26 capital letters in random order\n    my_letters = sample(LETTERS, 26)\n    )\n\n# for the first variable, use a single line of code in R to select 4 random rows and replace the numerical values in those rows with NA\n\n# m[1,1] &lt;- NA\n# m[5,4] &lt;- NA\n\ndf[sample(1:26, size=4), 1] &lt;- NA\n\n# for the first variable, write a single line of R code to identify which rows have the missing values.\nwhich(!complete.cases(df))\n\n[1]  1 12 21 25\n\n# re-order the entire data frame to arrange the second variable in alphabetical order\ndf &lt;- data.frame(df[,1], sort(df[,2]))\n\n# calculate the column mean for the first variable\nmean(df[,1], na.rm = T)\n\n[1] 6.169662"
  },
  {
    "objectID": "homework4.html#homework-4",
    "href": "homework4.html#homework-4",
    "title": "Homework 4",
    "section": "",
    "text": "Assign to the variable n_dims a single random integer between 3 and 10.\n\n\n# Assign to the variable n_dims a single random integer between 3 and 10.\nn_dims &lt;- sample(x=3:10, size=1)\nprint(n_dims)\n\n[1] 4\n\n# Create a vector of consecutive integers from 1 to n_dims^2\nn_vec &lt;- 1:n_dims^2\nprint(n_vec)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16\n\n# Use the sample function to randomly reshuffle these values\nn_shuffle &lt;- sample(x=n_vec, size=length(n_vec))\nprint(n_shuffle)\n\n [1]  8  5  1  2  6  4  9 14 11 13  7 16 15  3 10 12\n\n# create a square matrix with these elements\nn_mat &lt;- matrix(data=n_shuffle, nrow=sqrt(length(n_shuffle)))\n\n# print out the matrix\nprint(n_mat)\n\n     [,1] [,2] [,3] [,4]\n[1,]    8    6   11   15\n[2,]    5    4   13    3\n[3,]    1    9    7   10\n[4,]    2   14   16   12\n\n# find a function in r to transpose the matrix\nn_transpose &lt;- t(n_mat)\n\n# print it out again and note how it has changed.\nprint(n_transpose)\n\n     [,1] [,2] [,3] [,4]\n[1,]    8    5    1    2\n[2,]    6    4    9   14\n[3,]   11   13    7   16\n[4,]   15    3   10   12\n\n# calculate the sum and the mean of the elements in the first row and then the last row\nsum(n_transpose[1,])\n\n[1] 16\n\nmean(n_transpose[1,])\n\n[1] 4\n\nsum(n_transpose[sqrt(length(n_transpose)),])\n\n[1] 40\n\nmean(n_transpose[sqrt(length(n_transpose)),])\n\n[1] 10\n\n# read about the eigen() function and use it on your matrix\nn_eigen &lt;- eigen(n_transpose)\n\n# look carefully at the elements of $values and $vectors in the output. What kind of numbers are these?\n# dig in with the typeof() function to figure out their type.\ntypeof(n_eigen$values)\n\n[1] \"complex\"\n\ntypeof(n_eigen$vectors)\n\n[1] \"complex\"\n\n# These are all doubles\n# on my first run they were all doubles, but then rerunning it turned complex\n\n\nCreate a list with the following named elements:\n\n\n#  4 x 4 matrix filled with random uniform values\nmy_matrix &lt;- matrix(runif(16), nrow=4)\n\n# 100-element vector of TRUE or FALSE values. Do this efficiently by setting up a vector of random values and then applying an inequality to it\nmy_logical &lt;- sample(1:100, size=100) &gt; 50\n\n# 26-element vector of all the lower-case letters in random order\nmy_letters &lt;- sample(letters, size=26)\n\n### Then, complete the following steps:\n# create a new list, which has the element[2,2] from the matrix, the second element of the logical vector, and the second element of the letters vector.\nnew_list &lt;- list(m=my_matrix[2,2], lo=my_logical[2], le=my_letters[2])\ntypeof(new_list$m)\n\n[1] \"double\"\n\ntypeof(new_list$lo)\n\n[1] \"logical\"\n\ntypeof(new_list$le)\n\n[1] \"character\"\n\n# combine the underlying elements from the new list into a single atomic vector with the c() function\nnew_vec &lt;- c(new_list$m, new_list$lo, new_list$le)\ntypeof(new_vec)\n\n[1] \"character\"\n\n# this is type character.\n\n\nCreate a data frame with the two variables (= columns) and 26 cases (= rows) below:\n\n\ndf &lt;- data.frame(\n    # call the first variable my_unis and fill it with 26 random uniform values from 0 to 10\n    my_unis = runif(26, min=0, max=10),\n    # call the second variable my_letters and fill it with 26 capital letters in random order\n    my_letters = sample(LETTERS, 26)\n    )\n\n# for the first variable, use a single line of code in R to select 4 random rows and replace the numerical values in those rows with NA\n\n# m[1,1] &lt;- NA\n# m[5,4] &lt;- NA\n\ndf[sample(1:26, size=4), 1] &lt;- NA\n\n# for the first variable, write a single line of R code to identify which rows have the missing values.\nwhich(!complete.cases(df))\n\n[1]  1 12 21 25\n\n# re-order the entire data frame to arrange the second variable in alphabetical order\ndf &lt;- data.frame(df[,1], sort(df[,2]))\n\n# calculate the column mean for the first variable\nmean(df[,1], na.rm = T)\n\n[1] 6.169662"
  },
  {
    "objectID": "homework1.html",
    "href": "homework1.html",
    "title": "homework1",
    "section": "",
    "text": "This is Homework 1. It contains some R code.\n\nx=c(1,2,3,4)\n\ny=c(\"a\",\"b\",\"c\",\"d\")\n\nprint(x)\n\n[1] 1 2 3 4\n\nprint(y)\n\n[1] \"a\" \"b\" \"c\" \"d\""
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site: this is a test to make sure things work"
  },
  {
    "objectID": "homework3.html",
    "href": "homework3.html",
    "title": "Homework 3",
    "section": "",
    "text": "# Setting up variables:\nx &lt;- 1.1\na &lt;- 2.2\nb &lt;- 3.3\n\n# Assigning z to each expression\n# 1a:\nz &lt;- x^(a^b)\nprint(z)\n\n[1] 3.61714\n\n# 1b:\nz &lt;- (x^a)^b\nprint(z)\n\n[1] 1.997611\n\n# 1c:\nz &lt;- ((3*x^3)+(2*x^2)+(1))\n\nprint(z)\n\n[1] 7.413\n\n\n\n\n\n\n# 2a:\n# concatenating two seqs\nvec1 &lt;- c(seq(from=1, to=8), seq(from=7, to=1))\nprint(vec1)\n\n [1] 1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\n\n# 2b:\n# repeating 1 through 5 and using a vector inside of times to repeat numbers\nvec2 &lt;- rep(x=c(1:5), times=c(1:5))\nprint(vec2)\n\n [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5\n\n# 2c:\n# repeating 5 through 1 and using a vector inside of times to repeat numbers\nvec3 &lt;- rep(x=c(5:1), times=c(1:5))\nprint(vec3)\n\n [1] 5 4 4 3 3 3 2 2 2 2 1 1 1 1 1\n\n\n\n\n\n\n# using runif to generate two random cart coordinates\ncart &lt;- c(runif(1), runif(1))\nprint(cart)\n\n[1] 0.7664066 0.0704007\n\n# creating r and theta for polar coordinates\nr &lt;- sqrt((cart[1]^2) + (cart[2]^2))\ntheta &lt;- atan((cart[1]) / (cart[2]))\n\n# assigning polar coordinates\npol &lt;- c(r, theta)\nprint(pol)\n\n[1] 0.7696332 1.4791952\n\n\n\n\n\n\n# assigned queue\nqueue &lt;- c(\"sheep\", \"fox\", \"owl\", \"ant\")\nqueue &lt;- c(queue, \"serpent\")\nqueue &lt;- queue[-1]\nqueue &lt;- c(\"donkey\", queue)\nqueue &lt;- queue[-5]\nqueue &lt;- queue[-3]\nqueue &lt;- c(queue[1:2], \"aphid\", queue[3])\n\n# using which to figure out where aphid is\nwhich(queue==\"aphid\")\n\n[1] 3\n\n\n\n\n\n\n# assigning ints as a vector of 1 through 100\nints &lt;- c(1:100)\n\n# using a combo of indexing and which. Basically asking for the index to find number where the remainder of division is not 0 for each number.\nnot_div &lt;- ints[which(ints %% 2 != 0 & ints %% 3 != 0 & ints %% 7 != 0)] \n\nprint(not_div)\n\n [1]  1  5 11 13 17 19 23 25 29 31 37 41 43 47 53 55 59 61 65 67 71 73 79 83 85\n[26] 89 95 97"
  },
  {
    "objectID": "homework3.html#homework-3",
    "href": "homework3.html#homework-3",
    "title": "Homework 3",
    "section": "",
    "text": "# Setting up variables:\nx &lt;- 1.1\na &lt;- 2.2\nb &lt;- 3.3\n\n# Assigning z to each expression\n# 1a:\nz &lt;- x^(a^b)\nprint(z)\n\n[1] 3.61714\n\n# 1b:\nz &lt;- (x^a)^b\nprint(z)\n\n[1] 1.997611\n\n# 1c:\nz &lt;- ((3*x^3)+(2*x^2)+(1))\n\nprint(z)\n\n[1] 7.413\n\n\n\n\n\n\n# 2a:\n# concatenating two seqs\nvec1 &lt;- c(seq(from=1, to=8), seq(from=7, to=1))\nprint(vec1)\n\n [1] 1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\n\n# 2b:\n# repeating 1 through 5 and using a vector inside of times to repeat numbers\nvec2 &lt;- rep(x=c(1:5), times=c(1:5))\nprint(vec2)\n\n [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5\n\n# 2c:\n# repeating 5 through 1 and using a vector inside of times to repeat numbers\nvec3 &lt;- rep(x=c(5:1), times=c(1:5))\nprint(vec3)\n\n [1] 5 4 4 3 3 3 2 2 2 2 1 1 1 1 1\n\n\n\n\n\n\n# using runif to generate two random cart coordinates\ncart &lt;- c(runif(1), runif(1))\nprint(cart)\n\n[1] 0.7664066 0.0704007\n\n# creating r and theta for polar coordinates\nr &lt;- sqrt((cart[1]^2) + (cart[2]^2))\ntheta &lt;- atan((cart[1]) / (cart[2]))\n\n# assigning polar coordinates\npol &lt;- c(r, theta)\nprint(pol)\n\n[1] 0.7696332 1.4791952\n\n\n\n\n\n\n# assigned queue\nqueue &lt;- c(\"sheep\", \"fox\", \"owl\", \"ant\")\nqueue &lt;- c(queue, \"serpent\")\nqueue &lt;- queue[-1]\nqueue &lt;- c(\"donkey\", queue)\nqueue &lt;- queue[-5]\nqueue &lt;- queue[-3]\nqueue &lt;- c(queue[1:2], \"aphid\", queue[3])\n\n# using which to figure out where aphid is\nwhich(queue==\"aphid\")\n\n[1] 3\n\n\n\n\n\n\n# assigning ints as a vector of 1 through 100\nints &lt;- c(1:100)\n\n# using a combo of indexing and which. Basically asking for the index to find number where the remainder of division is not 0 for each number.\nnot_div &lt;- ints[which(ints %% 2 != 0 & ints %% 3 != 0 & ints %% 7 != 0)] \n\nprint(not_div)\n\n [1]  1  5 11 13 17 19 23 25 29 31 37 41 43 47 53 55 59 61 65 67 71 73 79 83 85\n[26] 89 95 97"
  },
  {
    "objectID": "homework5.html",
    "href": "homework5.html",
    "title": "Homework 5",
    "section": "",
    "text": "Create a funtion that takes the parameters required to run a logistic growth model and returns a dataframe with columns for population size and time.\n\n\n# These were testing variables for my own purposes\n# N0=2\n# r=0.5\n# K=30\n# t_fin=50\n# t_step=3\n\n### Creating function 'log_growth': Start function\nlog_growth &lt;- function(N0=5, r=0.1, K=100, t_fin=100, t_step=5){\n    # log_growth takes N0 (initial pop size), r (growth rate), K (carrying capacity), t_fin (the final time), and t_step (the number by which t increases)\n\n    # times: sequences from 0 to t_fin in steps of t_step\n    times &lt;- seq(from = 0, to = t_fin, by = t_step)\n    \n    # pop_df: creates a df with column time (=times) and population size.\n    pop_df &lt;- data.frame(t = times, N = NA)\n\n    # for loop: finds the length of times, then for every integer, finds t at location i of pop_df. Then, it runs the log growth equation for that number. N (output of equation) is then placed into N at location i of pop_df.\n    for(i in 1:length(times)){\n\n        t &lt;- pop_df$t[i]\n\n        N &lt;- ( K ) / ( 1 + ( ( K - N0 ) / N0 ) * ( exp(-r * t)) )\n\n        pop_df$N[i] &lt;- N\n    }\n\n    # actually return the dataframe\n    return(pop_df)\n\n}\n\n# testing\nlogdf_real &lt;- log_growth()\n\n\nCreate a second function that takes the above dataframe as its input and creates a plot of population size over time as a side effect.\n\n\n# load tidyverse\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.1\n✔ lubridate 1.9.5     ✔ tidyr     1.3.2\n✔ purrr     1.2.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n# create function for plot growth. Needs a df that has t (time) and N (pop size) columns. Default is above dataframe.\nplot_growth &lt;- function(log_df = logdf_real){\n\n    plot &lt;- ggplot(\n        data = log_df,\n        mapping = aes(\n            x = t,\n            y = N\n        )\n    ) + geom_point() + geom_line() + xlab(\"Time\") + ylab(\"Population Size\")\n\n    return(plot)\n\n}\n\n# callimg function\nplot_growth()"
  },
  {
    "objectID": "homework5.html#homework-5",
    "href": "homework5.html#homework-5",
    "title": "Homework 5",
    "section": "",
    "text": "Create a funtion that takes the parameters required to run a logistic growth model and returns a dataframe with columns for population size and time.\n\n\n# These were testing variables for my own purposes\n# N0=2\n# r=0.5\n# K=30\n# t_fin=50\n# t_step=3\n\n### Creating function 'log_growth': Start function\nlog_growth &lt;- function(N0=5, r=0.1, K=100, t_fin=100, t_step=5){\n    # log_growth takes N0 (initial pop size), r (growth rate), K (carrying capacity), t_fin (the final time), and t_step (the number by which t increases)\n\n    # times: sequences from 0 to t_fin in steps of t_step\n    times &lt;- seq(from = 0, to = t_fin, by = t_step)\n    \n    # pop_df: creates a df with column time (=times) and population size.\n    pop_df &lt;- data.frame(t = times, N = NA)\n\n    # for loop: finds the length of times, then for every integer, finds t at location i of pop_df. Then, it runs the log growth equation for that number. N (output of equation) is then placed into N at location i of pop_df.\n    for(i in 1:length(times)){\n\n        t &lt;- pop_df$t[i]\n\n        N &lt;- ( K ) / ( 1 + ( ( K - N0 ) / N0 ) * ( exp(-r * t)) )\n\n        pop_df$N[i] &lt;- N\n    }\n\n    # actually return the dataframe\n    return(pop_df)\n\n}\n\n# testing\nlogdf_real &lt;- log_growth()\n\n\nCreate a second function that takes the above dataframe as its input and creates a plot of population size over time as a side effect.\n\n\n# load tidyverse\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.1\n✔ lubridate 1.9.5     ✔ tidyr     1.3.2\n✔ purrr     1.2.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n# create function for plot growth. Needs a df that has t (time) and N (pop size) columns. Default is above dataframe.\nplot_growth &lt;- function(log_df = logdf_real){\n\n    plot &lt;- ggplot(\n        data = log_df,\n        mapping = aes(\n            x = t,\n            y = N\n        )\n    ) + geom_point() + geom_line() + xlab(\"Time\") + ylab(\"Population Size\")\n\n    return(plot)\n\n}\n\n# callimg function\nplot_growth()"
  },
  {
    "objectID": "homework7.html#section",
    "href": "homework7.html#section",
    "title": "Homework 7",
    "section": "### 2/25/26",
    "text": "### 2/25/26"
  },
  {
    "objectID": "homework7.html#loading-in-dataset-and-libraries",
    "href": "homework7.html#loading-in-dataset-and-libraries",
    "title": "Homework 7",
    "section": "Loading in dataset and libraries",
    "text": "Loading in dataset and libraries\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.1\n✔ lubridate 1.9.5     ✔ tidyr     1.3.2\n✔ purrr     1.2.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ndata(iris)\n\n\nExamine the structure of the iris data set. How many observations and variables are in the data set?\n\n\nstr(iris)\n\n'data.frame':   150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\n# 150 observations with 5 variables.\n\n\nCreate a new data frame iris1 that contains only the species virginica and versicolor with sepal lengths longer than 6 cm and sepal widths longer than 2.5 cm. How many observations and variables are in the data set?\n\n\niris1 &lt;- iris |&gt; \n    filter(\n        Species != \"setosa\" & Sepal.Length &gt; 6 & Sepal.Width &gt; 2.5\n    )\n\nstr(iris1)\n\n'data.frame':   56 obs. of  5 variables:\n $ Sepal.Length: num  7 6.4 6.9 6.5 6.3 6.6 6.1 6.7 6.1 6.1 ...\n $ Sepal.Width : num  3.2 3.2 3.1 2.8 3.3 2.9 2.9 3.1 2.8 2.8 ...\n $ Petal.Length: num  4.7 4.5 4.9 4.6 4.7 4.6 4.7 4.4 4 4.7 ...\n $ Petal.Width : num  1.4 1.5 1.5 1.5 1.6 1.3 1.4 1.4 1.3 1.2 ...\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 2 2 2 2 2 2 2 2 2 2 ...\n\n# there are 56 observations from 5 varaibles\n\n\nNow, create a iris2 data frame from iris1 that contains only the columns for Species, Sepal.Length, and Sepal.Width. How many observations and variables are in the data set?\n\n\niris2 &lt;- iris1 |&gt; select(\n    Species, Sepal.Length, Sepal.Width\n)\n\nstr(iris2)\n\n'data.frame':   56 obs. of  3 variables:\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 2 2 2 2 2 2 2 2 2 2 ...\n $ Sepal.Length: num  7 6.4 6.9 6.5 6.3 6.6 6.1 6.7 6.1 6.1 ...\n $ Sepal.Width : num  3.2 3.2 3.1 2.8 3.3 2.9 2.9 3.1 2.8 2.8 ...\n\n# 56 obs of 3 variables\n\n\nCreate an iris3 data frame from iris2 that orders the observations from largest to smallest sepal length. Show the first 6 rows of this data set.\n\n\niris3 &lt;- iris2 |&gt; arrange(\n    desc(Sepal.Length)\n)\n\nhead(iris3, 6)\n\n    Species Sepal.Length Sepal.Width\n1 virginica          7.9         3.8\n2 virginica          7.7         3.8\n3 virginica          7.7         2.6\n4 virginica          7.7         2.8\n5 virginica          7.7         3.0\n6 virginica          7.6         3.0\n\nstr(iris3)\n\n'data.frame':   56 obs. of  3 variables:\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ Sepal.Length: num  7.9 7.7 7.7 7.7 7.7 7.6 7.4 7.3 7.2 7.2 ...\n $ Sepal.Width : num  3.8 3.8 2.6 2.8 3 3 2.8 2.9 3.6 3.2 ...\n\n# 56 obs of 3 variables\n\n\nCreate an iris4 data frame from iris3 that creates a column with a sepal area (length * width) value for each observation. How many observations and variables are in the data set?\n\n\niris4 &lt;- iris3 |&gt; mutate(\n    Sepal.Area = Sepal.Length * Sepal.Width\n)\n\nstr(iris4)\n\n'data.frame':   56 obs. of  4 variables:\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ Sepal.Length: num  7.9 7.7 7.7 7.7 7.7 7.6 7.4 7.3 7.2 7.2 ...\n $ Sepal.Width : num  3.8 3.8 2.6 2.8 3 3 2.8 2.9 3.6 3.2 ...\n $ Sepal.Area  : num  30 29.3 20 21.6 23.1 ...\n\n# 56 obs of 4 varaibles\n\n\nCreate iris5 that calculates the average sepal length, the average sepal width, and the sample size of the entire iris4 data frame and print iris5.\n\n\niris5 &lt;- iris4 |&gt; summarise(\n    avg.Sepal.Width = mean(Sepal.Width),\n    avg.Sepal.Length = mean(Sepal.Length),\n    avg.Sepal.Area = mean(Sepal.Area),\n    samp.size = n()\n)\n\niris5\n\n  avg.Sepal.Width avg.Sepal.Length avg.Sepal.Area samp.size\n1        3.041071         6.698214       20.40464        56\n\n\n\nFinally, create iris6 that calculates the average sepal length, the average sepal width, and the sample size for each species of in the iris4 data frame and print iris6.\n\n\niris6 &lt;- iris4 |&gt; group_by(Species) |&gt; summarise(\n    avg.Sepal.Width = mean(Sepal.Width),\n    avg.Sepal.Length = mean(Sepal.Length),\n    avg.Sepal.Area = mean(Sepal.Area),\n    samp.size = n()\n)\n\niris6\n\n# A tibble: 2 × 5\n  Species    avg.Sepal.Width avg.Sepal.Length avg.Sepal.Area samp.size\n  &lt;fct&gt;                &lt;dbl&gt;            &lt;dbl&gt;          &lt;dbl&gt;     &lt;int&gt;\n1 versicolor            2.99             6.48           19.4        17\n2 virginica             3.06             6.79           20.8        39\n\n\n\nIn these exercises, you have successively modified different versions of the data frame iris1 iris2 iris3 iris4 iris5 iris6. At each stage, the output data frame from one operation serves as the input fro the next. A more efficient way to do this is to use the pipe operator %&gt;% from the tidyr package. See if you can rework all of your previous statements (except for iris5) into an extended piping operation that uses iris as the input and generates irisFinal as the output.\n\n\nirisFinal &lt;- iris |&gt; \n    filter(\n        Species != \"setosa\" & Sepal.Length &gt; 6 & Sepal.Width &gt; 2.5\n) |&gt; select(\n    Species, Sepal.Length, Sepal.Width\n) |&gt; arrange(\n    desc(Sepal.Length)\n) |&gt; mutate(\n    Sepal.Area = Sepal.Length * Sepal.Width\n) |&gt; group_by(\n    Species\n) |&gt; summarise(\n    avg.Sepal.Width = mean(Sepal.Width),\n    avg.Sepal.Length = mean(Sepal.Length),\n    avg.Sepal.Area = mean(Sepal.Area),\n    samp.size = n()\n)\n\nstr(irisFinal)\n\ntibble [2 × 5] (S3: tbl_df/tbl/data.frame)\n $ Species         : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 2 3\n $ avg.Sepal.Width : num [1:2] 2.99 3.06\n $ avg.Sepal.Length: num [1:2] 6.48 6.79\n $ avg.Sepal.Area  : num [1:2] 19.4 20.8\n $ samp.size       : int [1:2] 17 39\n\n\n\nCreate a ‘longer’ data frame using the original iris data set with three columns named “Species”, “Measure”, “Value”. The column “Species” will retain the species names of the data set. The column “Measure” will include whether the value corresponds to Sepal.Length, Sepal.Width, Petal.Length, or Petal.Width and the column “Value” will include the numerical values of those measurements.\n\n\niris.long &lt;- iris |&gt; \n    pivot_longer(\n        cols = c(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width),\n        names_to = \"Measure\",\n        values_to = \"Value\"\n    )\n\nhead(iris.long)\n\n# A tibble: 6 × 3\n  Species Measure      Value\n  &lt;fct&gt;   &lt;chr&gt;        &lt;dbl&gt;\n1 setosa  Sepal.Length   5.1\n2 setosa  Sepal.Width    3.5\n3 setosa  Petal.Length   1.4\n4 setosa  Petal.Width    0.2\n5 setosa  Sepal.Length   4.9\n6 setosa  Sepal.Width    3"
  }
]