[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "compbio_webpage2.0_2026",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\nHomework 1: Homework 1\nHomework 3: Homework 3\nHomework 4: Homework 4\nHomework 5: Homework 5"
  },
  {
    "objectID": "homework4.html",
    "href": "homework4.html",
    "title": "Homework 4",
    "section": "",
    "text": "Assign to the variable n_dims a single random integer between 3 and 10.\n\n\n# Assign to the variable n_dims a single random integer between 3 and 10.\nn_dims &lt;- sample(x=3:10, size=1)\nprint(n_dims)\n\n[1] 4\n\n# Create a vector of consecutive integers from 1 to n_dims^2\nn_vec &lt;- 1:n_dims^2\nprint(n_vec)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16\n\n# Use the sample function to randomly reshuffle these values\nn_shuffle &lt;- sample(x=n_vec, size=length(n_vec))\nprint(n_shuffle)\n\n [1]  5  9  4 16 14 10 12 11  2  3  7  8  6  1 15 13\n\n# create a square matrix with these elements\nn_mat &lt;- matrix(data=n_shuffle, nrow=sqrt(length(n_shuffle)))\n\n# print out the matrix\nprint(n_mat)\n\n     [,1] [,2] [,3] [,4]\n[1,]    5   14    2    6\n[2,]    9   10    3    1\n[3,]    4   12    7   15\n[4,]   16   11    8   13\n\n# find a function in r to transpose the matrix\nn_transpose &lt;- t(n_mat)\n\n# print it out again and note how it has changed.\nprint(n_transpose)\n\n     [,1] [,2] [,3] [,4]\n[1,]    5    9    4   16\n[2,]   14   10   12   11\n[3,]    2    3    7    8\n[4,]    6    1   15   13\n\n# calculate the sum and the mean of the elements in the first row and then the last row\nsum(n_transpose[1,])\n\n[1] 34\n\nmean(n_transpose[1,])\n\n[1] 8.5\n\nsum(n_transpose[sqrt(length(n_transpose)),])\n\n[1] 35\n\nmean(n_transpose[sqrt(length(n_transpose)),])\n\n[1] 8.75\n\n# read about the eigen() function and use it on your matrix\nn_eigen &lt;- eigen(n_transpose)\n\n# look carefully at the elements of $values and $vectors in the output. What kind of numbers are these?\n# dig in with the typeof() function to figure out their type.\ntypeof(n_eigen$values)\n\n[1] \"double\"\n\ntypeof(n_eigen$vectors)\n\n[1] \"double\"\n\n# These are all doubles\n# on my first run they were all doubles, but then rerunning it turned complex\n\n\nCreate a list with the following named elements:\n\n\n#  4 x 4 matrix filled with random uniform values\nmy_matrix &lt;- matrix(runif(16), nrow=4)\n\n# 100-element vector of TRUE or FALSE values. Do this efficiently by setting up a vector of random values and then applying an inequality to it\nmy_logical &lt;- sample(1:100, size=100) &gt; 50\n\n# 26-element vector of all the lower-case letters in random order\nmy_letters &lt;- sample(letters, size=26)\n\n### Then, complete the following steps:\n# create a new list, which has the element[2,2] from the matrix, the second element of the logical vector, and the second element of the letters vector.\nnew_list &lt;- list(m=my_matrix[2,2], lo=my_logical[2], le=my_letters[2])\ntypeof(new_list$m)\n\n[1] \"double\"\n\ntypeof(new_list$lo)\n\n[1] \"logical\"\n\ntypeof(new_list$le)\n\n[1] \"character\"\n\n# combine the underlying elements from the new list into a single atomic vector with the c() function\nnew_vec &lt;- c(new_list$m, new_list$lo, new_list$le)\ntypeof(new_vec)\n\n[1] \"character\"\n\n# this is type character.\n\n\nCreate a data frame with the two variables (= columns) and 26 cases (= rows) below:\n\n\ndf &lt;- data.frame(\n    # call the first variable my_unis and fill it with 26 random uniform values from 0 to 10\n    my_unis = runif(26, min=0, max=10),\n    # call the second variable my_letters and fill it with 26 capital letters in random order\n    my_letters = sample(LETTERS, 26)\n    )\n\n# for the first variable, use a single line of code in R to select 4 random rows and replace the numerical values in those rows with NA\n\n# m[1,1] &lt;- NA\n# m[5,4] &lt;- NA\n\ndf[sample(1:26, size=4), 1] &lt;- NA\n\n# for the first variable, write a single line of R code to identify which rows have the missing values.\nwhich(!complete.cases(df))\n\n[1]  3 14 20 21\n\n# re-order the entire data frame to arrange the second variable in alphabetical order\ndf &lt;- data.frame(df[,1], sort(df[,2]))\n\n# calculate the column mean for the first variable\nmean(df[,1], na.rm = T)\n\n[1] 5.706528"
  },
  {
    "objectID": "homework4.html#homework-4",
    "href": "homework4.html#homework-4",
    "title": "Homework 4",
    "section": "",
    "text": "Assign to the variable n_dims a single random integer between 3 and 10.\n\n\n# Assign to the variable n_dims a single random integer between 3 and 10.\nn_dims &lt;- sample(x=3:10, size=1)\nprint(n_dims)\n\n[1] 4\n\n# Create a vector of consecutive integers from 1 to n_dims^2\nn_vec &lt;- 1:n_dims^2\nprint(n_vec)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16\n\n# Use the sample function to randomly reshuffle these values\nn_shuffle &lt;- sample(x=n_vec, size=length(n_vec))\nprint(n_shuffle)\n\n [1]  5  9  4 16 14 10 12 11  2  3  7  8  6  1 15 13\n\n# create a square matrix with these elements\nn_mat &lt;- matrix(data=n_shuffle, nrow=sqrt(length(n_shuffle)))\n\n# print out the matrix\nprint(n_mat)\n\n     [,1] [,2] [,3] [,4]\n[1,]    5   14    2    6\n[2,]    9   10    3    1\n[3,]    4   12    7   15\n[4,]   16   11    8   13\n\n# find a function in r to transpose the matrix\nn_transpose &lt;- t(n_mat)\n\n# print it out again and note how it has changed.\nprint(n_transpose)\n\n     [,1] [,2] [,3] [,4]\n[1,]    5    9    4   16\n[2,]   14   10   12   11\n[3,]    2    3    7    8\n[4,]    6    1   15   13\n\n# calculate the sum and the mean of the elements in the first row and then the last row\nsum(n_transpose[1,])\n\n[1] 34\n\nmean(n_transpose[1,])\n\n[1] 8.5\n\nsum(n_transpose[sqrt(length(n_transpose)),])\n\n[1] 35\n\nmean(n_transpose[sqrt(length(n_transpose)),])\n\n[1] 8.75\n\n# read about the eigen() function and use it on your matrix\nn_eigen &lt;- eigen(n_transpose)\n\n# look carefully at the elements of $values and $vectors in the output. What kind of numbers are these?\n# dig in with the typeof() function to figure out their type.\ntypeof(n_eigen$values)\n\n[1] \"double\"\n\ntypeof(n_eigen$vectors)\n\n[1] \"double\"\n\n# These are all doubles\n# on my first run they were all doubles, but then rerunning it turned complex\n\n\nCreate a list with the following named elements:\n\n\n#  4 x 4 matrix filled with random uniform values\nmy_matrix &lt;- matrix(runif(16), nrow=4)\n\n# 100-element vector of TRUE or FALSE values. Do this efficiently by setting up a vector of random values and then applying an inequality to it\nmy_logical &lt;- sample(1:100, size=100) &gt; 50\n\n# 26-element vector of all the lower-case letters in random order\nmy_letters &lt;- sample(letters, size=26)\n\n### Then, complete the following steps:\n# create a new list, which has the element[2,2] from the matrix, the second element of the logical vector, and the second element of the letters vector.\nnew_list &lt;- list(m=my_matrix[2,2], lo=my_logical[2], le=my_letters[2])\ntypeof(new_list$m)\n\n[1] \"double\"\n\ntypeof(new_list$lo)\n\n[1] \"logical\"\n\ntypeof(new_list$le)\n\n[1] \"character\"\n\n# combine the underlying elements from the new list into a single atomic vector with the c() function\nnew_vec &lt;- c(new_list$m, new_list$lo, new_list$le)\ntypeof(new_vec)\n\n[1] \"character\"\n\n# this is type character.\n\n\nCreate a data frame with the two variables (= columns) and 26 cases (= rows) below:\n\n\ndf &lt;- data.frame(\n    # call the first variable my_unis and fill it with 26 random uniform values from 0 to 10\n    my_unis = runif(26, min=0, max=10),\n    # call the second variable my_letters and fill it with 26 capital letters in random order\n    my_letters = sample(LETTERS, 26)\n    )\n\n# for the first variable, use a single line of code in R to select 4 random rows and replace the numerical values in those rows with NA\n\n# m[1,1] &lt;- NA\n# m[5,4] &lt;- NA\n\ndf[sample(1:26, size=4), 1] &lt;- NA\n\n# for the first variable, write a single line of R code to identify which rows have the missing values.\nwhich(!complete.cases(df))\n\n[1]  3 14 20 21\n\n# re-order the entire data frame to arrange the second variable in alphabetical order\ndf &lt;- data.frame(df[,1], sort(df[,2]))\n\n# calculate the column mean for the first variable\nmean(df[,1], na.rm = T)\n\n[1] 5.706528"
  },
  {
    "objectID": "homework1.html",
    "href": "homework1.html",
    "title": "homework1",
    "section": "",
    "text": "This is Homework 1. It contains some R code.\n\nx=c(1,2,3,4)\n\ny=c(\"a\",\"b\",\"c\",\"d\")\n\nprint(x)\n\n[1] 1 2 3 4\n\nprint(y)\n\n[1] \"a\" \"b\" \"c\" \"d\""
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site: this is a test to make sure things work"
  },
  {
    "objectID": "homework3.html",
    "href": "homework3.html",
    "title": "Homework 3",
    "section": "",
    "text": "# Setting up variables:\nx &lt;- 1.1\na &lt;- 2.2\nb &lt;- 3.3\n\n# Assigning z to each expression\n# 1a:\nz &lt;- x^(a^b)\nprint(z)\n\n[1] 3.61714\n\n# 1b:\nz &lt;- (x^a)^b\nprint(z)\n\n[1] 1.997611\n\n# 1c:\nz &lt;- ((3*x^3)+(2*x^2)+(1))\n\nprint(z)\n\n[1] 7.413\n\n\n\n\n\n\n# 2a:\n# concatenating two seqs\nvec1 &lt;- c(seq(from=1, to=8), seq(from=7, to=1))\nprint(vec1)\n\n [1] 1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\n\n# 2b:\n# repeating 1 through 5 and using a vector inside of times to repeat numbers\nvec2 &lt;- rep(x=c(1:5), times=c(1:5))\nprint(vec2)\n\n [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5\n\n# 2c:\n# repeating 5 through 1 and using a vector inside of times to repeat numbers\nvec3 &lt;- rep(x=c(5:1), times=c(1:5))\nprint(vec3)\n\n [1] 5 4 4 3 3 3 2 2 2 2 1 1 1 1 1\n\n\n\n\n\n\n# using runif to generate two random cart coordinates\ncart &lt;- c(runif(1), runif(1))\nprint(cart)\n\n[1] 0.9159184 0.5570860\n\n# creating r and theta for polar coordinates\nr &lt;- sqrt((cart[1]^2) + (cart[2]^2))\ntheta &lt;- atan((cart[1]) / (cart[2]))\n\n# assigning polar coordinates\npol &lt;- c(r, theta)\nprint(pol)\n\n[1] 1.072031 1.024350\n\n\n\n\n\n\n# assigned queue\nqueue &lt;- c(\"sheep\", \"fox\", \"owl\", \"ant\")\nqueue &lt;- c(queue, \"serpent\")\nqueue &lt;- queue[-1]\nqueue &lt;- c(\"donkey\", queue)\nqueue &lt;- queue[-5]\nqueue &lt;- queue[-3]\nqueue &lt;- c(queue[1:2], \"aphid\", queue[3])\n\n# using which to figure out where aphid is\nwhich(queue==\"aphid\")\n\n[1] 3\n\n\n\n\n\n\n# assigning ints as a vector of 1 through 100\nints &lt;- c(1:100)\n\n# using a combo of indexing and which. Basically asking for the index to find number where the remainder of division is not 0 for each number.\nnot_div &lt;- ints[which(ints %% 2 != 0 & ints %% 3 != 0 & ints %% 7 != 0)] \n\nprint(not_div)\n\n [1]  1  5 11 13 17 19 23 25 29 31 37 41 43 47 53 55 59 61 65 67 71 73 79 83 85\n[26] 89 95 97"
  },
  {
    "objectID": "homework3.html#homework-3",
    "href": "homework3.html#homework-3",
    "title": "Homework 3",
    "section": "",
    "text": "# Setting up variables:\nx &lt;- 1.1\na &lt;- 2.2\nb &lt;- 3.3\n\n# Assigning z to each expression\n# 1a:\nz &lt;- x^(a^b)\nprint(z)\n\n[1] 3.61714\n\n# 1b:\nz &lt;- (x^a)^b\nprint(z)\n\n[1] 1.997611\n\n# 1c:\nz &lt;- ((3*x^3)+(2*x^2)+(1))\n\nprint(z)\n\n[1] 7.413\n\n\n\n\n\n\n# 2a:\n# concatenating two seqs\nvec1 &lt;- c(seq(from=1, to=8), seq(from=7, to=1))\nprint(vec1)\n\n [1] 1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\n\n# 2b:\n# repeating 1 through 5 and using a vector inside of times to repeat numbers\nvec2 &lt;- rep(x=c(1:5), times=c(1:5))\nprint(vec2)\n\n [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5\n\n# 2c:\n# repeating 5 through 1 and using a vector inside of times to repeat numbers\nvec3 &lt;- rep(x=c(5:1), times=c(1:5))\nprint(vec3)\n\n [1] 5 4 4 3 3 3 2 2 2 2 1 1 1 1 1\n\n\n\n\n\n\n# using runif to generate two random cart coordinates\ncart &lt;- c(runif(1), runif(1))\nprint(cart)\n\n[1] 0.9159184 0.5570860\n\n# creating r and theta for polar coordinates\nr &lt;- sqrt((cart[1]^2) + (cart[2]^2))\ntheta &lt;- atan((cart[1]) / (cart[2]))\n\n# assigning polar coordinates\npol &lt;- c(r, theta)\nprint(pol)\n\n[1] 1.072031 1.024350\n\n\n\n\n\n\n# assigned queue\nqueue &lt;- c(\"sheep\", \"fox\", \"owl\", \"ant\")\nqueue &lt;- c(queue, \"serpent\")\nqueue &lt;- queue[-1]\nqueue &lt;- c(\"donkey\", queue)\nqueue &lt;- queue[-5]\nqueue &lt;- queue[-3]\nqueue &lt;- c(queue[1:2], \"aphid\", queue[3])\n\n# using which to figure out where aphid is\nwhich(queue==\"aphid\")\n\n[1] 3\n\n\n\n\n\n\n# assigning ints as a vector of 1 through 100\nints &lt;- c(1:100)\n\n# using a combo of indexing and which. Basically asking for the index to find number where the remainder of division is not 0 for each number.\nnot_div &lt;- ints[which(ints %% 2 != 0 & ints %% 3 != 0 & ints %% 7 != 0)] \n\nprint(not_div)\n\n [1]  1  5 11 13 17 19 23 25 29 31 37 41 43 47 53 55 59 61 65 67 71 73 79 83 85\n[26] 89 95 97"
  },
  {
    "objectID": "homework5.html",
    "href": "homework5.html",
    "title": "Homework 5",
    "section": "",
    "text": "Create a funtion that takes the parameters required to run a logistic growth model and returns a dataframe with columns for population size and time.\n\n\n# These were testing variables for my own purposes\n# N0=2\n# r=0.5\n# K=30\n# t_fin=50\n# t_step=3\n\n### Creating function 'log_growth': Start function\nlog_growth &lt;- function(N0=5, r=0.1, K=100, t_fin=100, t_step=5){\n    # log_growth takes N0 (initial pop size), r (growth rate), K (carrying capacity), t_fin (the final time), and t_step (the number by which t increases)\n\n    # times: sequences from 0 to t_fin in steps of t_step\n    times &lt;- seq(from = 0, to = t_fin, by = t_step)\n    \n    # pop_df: creates a df with column time (=times) and population size.\n    pop_df &lt;- data.frame(t = times, N = NA)\n\n    # for loop: finds the length of times, then for every integer, finds t at location i of pop_df. Then, it runs the log growth equation for that number. N (output of equation) is then placed into N at location i of pop_df.\n    for(i in 1:length(times)){\n\n        t &lt;- pop_df$t[i]\n\n        N &lt;- ( K ) / ( 1 + ( ( K - N0 ) / N0 ) * ( exp(-r * t)) )\n\n        pop_df$N[i] &lt;- N\n    }\n\n    # actually return the dataframe\n    return(pop_df)\n\n}\n\n# testing\nlogdf_real &lt;- log_growth()\n\n\nCreate a second function that takes the above dataframe as its input and creates a plot of population size over time as a side effect.\n\n\n# load tidyverse\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.1\n✔ lubridate 1.9.5     ✔ tidyr     1.3.2\n✔ purrr     1.2.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n# create function for plot growth. Needs a df that has t (time) and N (pop size) columns. Default is above dataframe.\nplot_growth &lt;- function(log_df = logdf_real){\n\n    plot &lt;- ggplot(\n        data = log_df,\n        mapping = aes(\n            x = t,\n            y = N\n        )\n    ) + geom_point() + geom_line() + xlab(\"Time\") + ylab(\"Population Size\")\n\n    return(plot)\n\n}\n\n# callimg function\nplot_growth()"
  },
  {
    "objectID": "homework5.html#homework-5",
    "href": "homework5.html#homework-5",
    "title": "Homework 5",
    "section": "",
    "text": "Create a funtion that takes the parameters required to run a logistic growth model and returns a dataframe with columns for population size and time.\n\n\n# These were testing variables for my own purposes\n# N0=2\n# r=0.5\n# K=30\n# t_fin=50\n# t_step=3\n\n### Creating function 'log_growth': Start function\nlog_growth &lt;- function(N0=5, r=0.1, K=100, t_fin=100, t_step=5){\n    # log_growth takes N0 (initial pop size), r (growth rate), K (carrying capacity), t_fin (the final time), and t_step (the number by which t increases)\n\n    # times: sequences from 0 to t_fin in steps of t_step\n    times &lt;- seq(from = 0, to = t_fin, by = t_step)\n    \n    # pop_df: creates a df with column time (=times) and population size.\n    pop_df &lt;- data.frame(t = times, N = NA)\n\n    # for loop: finds the length of times, then for every integer, finds t at location i of pop_df. Then, it runs the log growth equation for that number. N (output of equation) is then placed into N at location i of pop_df.\n    for(i in 1:length(times)){\n\n        t &lt;- pop_df$t[i]\n\n        N &lt;- ( K ) / ( 1 + ( ( K - N0 ) / N0 ) * ( exp(-r * t)) )\n\n        pop_df$N[i] &lt;- N\n    }\n\n    # actually return the dataframe\n    return(pop_df)\n\n}\n\n# testing\nlogdf_real &lt;- log_growth()\n\n\nCreate a second function that takes the above dataframe as its input and creates a plot of population size over time as a side effect.\n\n\n# load tidyverse\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.1\n✔ lubridate 1.9.5     ✔ tidyr     1.3.2\n✔ purrr     1.2.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n# create function for plot growth. Needs a df that has t (time) and N (pop size) columns. Default is above dataframe.\nplot_growth &lt;- function(log_df = logdf_real){\n\n    plot &lt;- ggplot(\n        data = log_df,\n        mapping = aes(\n            x = t,\n            y = N\n        )\n    ) + geom_point() + geom_line() + xlab(\"Time\") + ylab(\"Population Size\")\n\n    return(plot)\n\n}\n\n# callimg function\nplot_growth()"
  }
]